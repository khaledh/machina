# Machina programming language grammar

# Top-level
Module             ::= Decl*

Decl               ::= TypeDecl | FunctionDecl | Function

# Type Declarations
TypeDecl           ::= "type" Identifier "=" TypeDeclBody
TypeDeclBody       ::= TypeAliasDef
                     | StructDef
                     | EnumDef

TypeAliasDef       ::=  TypeExpr ";"?

StructDef          ::= "{" StructFieldList? "}"
StructFieldList    ::= StructField ("," StructField)* ","?
StructField        ::= Identifier ":" TypeExpr

EnumDef            ::= EnumVariantDef ("|" EnumVariantDef)* ";"?
EnumVariantDef     ::= Identifier ( "(" TypeExprList ")" )?

# Type Expressions
TypeExpr           ::= UnitType | NamedType | ArrayType | SliceType | TupleType | RangeType | HeapType

UnitType           ::= "()"
NamedType          ::= Identifier
ArrayType          ::= TypeExpr "[" IntLitList "]"
SliceType          ::= TypeExpr "[" "]"
TupleType          ::= "(" TypeExpr "," ( TypeExprList )? ")"
RangeType          ::= "range" "(" IntLit ("," IntLit)? ")"
HeapType           ::= "^" TypeExpr

TypeExprList       ::= TypeExpr ( "," TypeExpr )* ","?
IntLitList         ::= IntLit ("," IntLit)* ","?

# Functions
FunctionSig        ::= "fn" Identifier "(" FunctionParamList? ")" ( "->" TypeExpr )?

FunctionDecl       ::= FunctionSig ";"

Function           ::= FunctionSig Block
FunctionParamList  ::= FunctionParam ("," FunctionParam)* ","?
FunctionParam      ::= FunctionParamMode? Identifier ":" TypeExpr
FunctionParamMode  ::= "inout"

# Blocks
Block              ::= "{" BlockItem* (Expr ";"?)? "}"
BlockItem          ::= StmtExpr | Expr ";"

# Statement Expressions
StmtExpr           ::= LetBind | VarBind | Assign | While | For

# Binding
LetBind            ::= "let" Pattern ( ":" TypeExpr )? "=" Expr ";"
VarBind            ::= "var" Pattern ( ":" TypeExpr )? "=" Expr ";"

# Assignment
Assign             ::= PostfixExpr "=" Expr ";"

# Loops
While              ::= "while" Expr Block
For                ::= "for" Pattern "in" (RangeExpr | Expr) Block

RangeExpr          ::= IntLit ".." IntLit

# Patterns
Pattern            ::= IdentPattern | ArrayPattern | TuplePattern | StructPattern
IdentPattern       ::= Identifier
ArrayPattern       ::= "[" PatternList "]"
TuplePattern       ::= "(" Pattern "," PatternList? ")"
StructPattern      ::= Identifier "{" StructPatternFieldList? "}"

StructPatternFieldList ::= StructPatternField ("," StructPatternField)* ","?
StructPatternField ::= Identifier ( ":" Pattern )?

PatternList        ::= Pattern ( "," Pattern )* ","?

# Expressions
Expr               ::= If | Match | InfixExpr

# Control flow
If                 ::= "if" Expr Block ( "else" Block )?

Match              ::= "match" Expr "{" MatchArm ("," MatchArm )* ","? "}"
MatchArm           ::= MatchPattern "=>" Expr
MatchPattern       ::= "_" | EnumVariantPattern
EnumVariantPattern ::= Identifier ("::" Identifier)? ( "(" IdentList? ")" )?
IdentList          ::= Identifier ("," Identifier)* ","?

# Operator Precedence (Lowest to Highest)
# 0. Logical OR (||)
# 1. Logical AND (&&)
# 2. Bitwise OR (|)
# 3. Bitwise XOR (^)
# 4. Bitwise AND (&)
# 5. Comparison (==, !=, <, <=, >, >=)
# 6. Shift (<<, >>)
# 7. Additive (+, -)
# 8. Multiplicative (*, /, %)
# 9. Unary (-, !, ~)
# 10. Postfix

InfixExpr          ::= OrExpr

OrExpr             ::= AndExpr ( "||" AndExpr )*
AndExpr            ::= BitOrExpr ( "&&" BitOrExpr )*
BitOrExpr          ::= BitXorExpr ( "|" BitXorExpr )*
BitXorExpr         ::= BitAndExpr ( "^" BitAndExpr )*
BitAndExpr         ::= CompareExpr ( "&" CompareExpr )*
CompareExpr        ::= ShiftExpr ( ( "==" | "!=" | "<" | "<=" | ">" | ">=" ) ShiftExpr )*
ShiftExpr          ::= AddExpr ( ( "<<" | ">>" ) AddExpr )*
AddExpr            ::= MulExpr ( ( "+" | "-" ) MulExpr )*
MulExpr            ::= UnaryExpr ( ( "*" | "/" | "%" ) UnaryExpr )*
UnaryExpr          ::= ( "-" | "!" | "~" | "^" ) UnaryExpr
                     | "move" UnaryExpr
                     | PostfixExpr

PostfixExpr        ::= Primary ( Call | ArrayIndex | SliceRange | TupleField | StructField )*

Call               ::= "(" ExprList? ")"
ArrayIndex         ::= "[" ExprList "]"
SliceRange         ::= "[" Expr? ".." Expr? "]"
TupleField         ::= "." IntLit
StructField        ::= "." Identifier

Primary            ::= Literal
                     | Identifier
                     | EnumVariant
                     | StructUpdate
                     | "(" Expr ")"
                     | Block

Literal            ::= UnitLit | IntLit | BoolLit | CharLit | StringLit | StringFmt
                     | ArrayLit | TupleLit | StructLit

ArrayLit           ::= TypeExpr? "[" ExprList "]"
                     | TypeExpr? "[" Expr ";" IntLit "]"
TupleLit           ::= "(" Expr "," ExprList? ")"

StructLit          ::= Identifier "{" StructLitFieldList? "}"
StructLitFieldList ::= StructLitField ("," StructLitField)* ","?
StructLitField     ::= Identifier ":" Expr

StructUpdate       ::= "{" Expr "|" StructUpdateField ("," StructUpdateField)* ","? "}"
StructUpdateField  ::= Identifier ":" Expr

EnumVariant        ::= Identifier "::" Identifier ( "(" ExprList ")" )?

# Common
ExprList           ::= Expr ( "," Expr )* ","?

# Terminals
UnitLit            ::= "()"
BoolLit            ::= "true" | "false"
IntLit             ::= [0-9]+
CharLit            ::= '\'' (char | escape) '\''
StringLit          ::= '"' (string-char | escape)* '"'
StringFmt          ::= "f" StringLit

Identifier         ::= [a-zA-Z_][a-zA-Z0-9_]*
