#ifndef MC_MACHINE_RUNTIME_H
#define MC_MACHINE_RUNTIME_H

#include <stdint.h>

// Managed typestate runtime core.
//
// V1 scope in this module:
// - machine table and lifecycle state
// - bounded per-machine FIFO mailboxes
// - global ready queue
// - deterministic single-dispatch entrypoints
// - transaction commit/rollback scaffolding for state/outbox/subscriptions
// - dead-letter and fault hook scaffolding

// Stable runtime identifier for a managed machine slot.
// IDs are 1-based (0 is reserved as invalid).
typedef uint32_t mc_machine_id_t;

// Capsule-deterministic event kind tag generated by the compiler descriptor
// builder. One payload type maps to one tag within a capsule.
typedef uint64_t mc_machine_event_kind_t;

// Opaque state token owned by compiler-generated typestate code.
// V1 execution model treats this as an implementation-defined payload pointer.
typedef uint64_t mc_machine_state_token_t;

// Payload layout identifier generated by compiler descriptors. Runtime uses this
// id to select decode/drop glue on commit/rollback/dead-letter paths.
typedef uint64_t mc_payload_layout_id_t;

// High-bit ownership marker carried in envelope payload layout ids.
// When set, payload word is treated as runtime-owned boxed storage and should
// be released on envelope/pending cleanup paths.
#define MC_PAYLOAD_LAYOUT_OWNED_MASK (1ull << 63)
#define MC_PAYLOAD_LAYOUT_ID_MASK (~MC_PAYLOAD_LAYOUT_OWNED_MASK)

static inline uint8_t mc_payload_layout_is_owned(mc_payload_layout_id_t payload_layout) {
    return (payload_layout & MC_PAYLOAD_LAYOUT_OWNED_MASK) != 0;
}

static inline mc_payload_layout_id_t mc_payload_layout_id(
    mc_payload_layout_id_t payload_layout
) {
    return payload_layout & MC_PAYLOAD_LAYOUT_ID_MASK;
}

typedef enum mc_machine_lifecycle {
    // Machine exists, can buffer mailbox messages, but cannot dispatch yet.
    MC_MACHINE_CREATED = 0,
    // Machine can receive and dispatch mailbox envelopes.
    MC_MACHINE_RUNNING = 1,
    // Machine encountered a fault during dispatch and is quarantined.
    MC_MACHINE_FAULTED = 2,
    // Machine is deliberately stopped and does not accept new work.
    MC_MACHINE_STOPPED = 3,
} mc_machine_lifecycle_t;

typedef enum mc_machine_fault_policy {
    // Fault transitions machine to FAULTED.
    MC_FAULT_POLICY_MARK_FAULTED = 0,
    // Fault transitions machine to STOPPED.
    MC_FAULT_POLICY_MARK_STOPPED = 1,
} mc_machine_fault_policy_t;

typedef enum mc_mailbox_enqueue_result {
    // Envelope was accepted.
    MC_MAILBOX_ENQUEUE_OK = 0,
    // Destination machine id does not exist.
    MC_MAILBOX_ENQUEUE_MACHINE_UNKNOWN = 1,
    // Destination exists but does not accept enqueues (FAULTED/STOPPED).
    MC_MAILBOX_ENQUEUE_MACHINE_NOT_RUNNING = 2,
    // Destination mailbox is full.
    MC_MAILBOX_ENQUEUE_FULL = 3,
} mc_mailbox_enqueue_result_t;

typedef enum mc_dead_letter_reason {
    // Enqueue target did not resolve to a machine.
    MC_DEAD_LETTER_UNKNOWN_MACHINE = 1,
    // Enqueue target machine is stopped.
    MC_DEAD_LETTER_STOPPED_MACHINE = 2,
    // Enqueue target machine is faulted.
    MC_DEAD_LETTER_FAULTED_MACHINE = 3,
    // Enqueue target mailbox was at capacity.
    MC_DEAD_LETTER_MAILBOX_FULL = 4,
    // Reply attempted with unknown/consumed reply capability id.
    MC_DEAD_LETTER_REPLY_CAP_UNKNOWN = 5,
} mc_dead_letter_reason_t;

typedef enum mc_dispatch_result {
    // Handler completed normally.
    MC_DISPATCH_OK = 0,
    // Handler failed; runtime applies fault policy.
    MC_DISPATCH_FAULT = 1,
    // Handler requested stop.
    MC_DISPATCH_STOP = 2,
} mc_dispatch_result_t;

// Internal fault code used when transactional commit preflight fails.
#define MC_FAULT_CODE_TXN_COMMIT_REJECTED 1u

// Minimal envelope used by v1 runtime tests and scheduler plumbing.
// Higher-level protocol routing metadata will extend this over time.
typedef struct mc_machine_envelope {
    // Logical payload kind/type tag.
    mc_machine_event_kind_t kind;
    // Source machine id (0 when external/unknown).
    uint64_t src;
    // Request-side capability id delivered to responder.
    // Zero for non-request envelopes.
    uint64_t reply_cap_id;
    // Response-side correlation id delivered to requester.
    // Zero for non-response envelopes.
    uint64_t pending_id;
    // Boxed payload ABI (v1):
    // - payload0: pointer to heap-owned payload box.
    // - payload1: payload layout metadata (layout id + ownership bit).
    //   Use `mc_payload_layout_id(...)` to recover canonical layout id.
    uint64_t payload0;
    mc_payload_layout_id_t payload1;
    // Correlated origin request payload ABI (response envelopes only):
    // - origin_payload0: pointer/int payload word of originating request.
    // - origin_payload1: payload layout id of originating request.
    // Zero for non-response envelopes or when unavailable.
    uint64_t origin_payload0;
    mc_payload_layout_id_t origin_payload1;
    // Correlated origin request-site key (response envelopes only).
    // Zero for non-response envelopes and unlabeled request sites.
    uint64_t origin_request_site_key;
} mc_machine_envelope_t;

typedef enum mc_machine_reply_result {
    MC_REPLY_OK = 0,
    MC_REPLY_CAP_UNKNOWN = 1,
    MC_REPLY_DEST_UNKNOWN = 2,
    MC_REPLY_DEST_NOT_RUNNING = 3,
    MC_REPLY_FULL = 4,
} mc_machine_reply_result_t;

// One-step execution status for managed runtime bridge helpers.
typedef enum mc_machine_step_status {
    // No runnable machine was available.
    MC_STEP_IDLE = 0,
    // Exactly one envelope dispatch was executed.
    MC_STEP_DID_WORK = 1,
    // Dispatch executed and transitioned a machine via fault policy.
    MC_STEP_FAULTED = 2,
} mc_machine_step_status_t;

// One staged outbox delivery emitted by a successful transition.
typedef struct mc_machine_outbox_effect {
    mc_machine_id_t dst;
    mc_machine_envelope_t env;
} mc_machine_outbox_effect_t;

// One staged request delivery emitted by a successful transition.
//
// `pending_id` is the capability id to insert into pending-correlation table on
// commit. Commit rejects duplicate/zero/active ids.
typedef struct mc_machine_request_effect {
    mc_machine_id_t dst;
    uint64_t pending_id;
    // Compiler-provided request-site identity (0 when unknown/not provided).
    uint64_t request_site_key;
    mc_machine_envelope_t env;
} mc_machine_request_effect_t;

// One staged reply delivery emitted by a successful transition.
//
// `reply_cap_id` identifies the pending requester route to consume on commit.
typedef struct mc_machine_reply_effect {
    uint64_t reply_cap_id;
    mc_machine_envelope_t env;
} mc_machine_reply_effect_t;

// One descriptor dispatch row keyed by (state tag, event kind, request-site).
typedef struct mc_machine_dispatch_row {
    uint64_t state_tag;
    mc_machine_event_kind_t event_kind;
    // Optional response request-site match key. Zero means wildcard.
    uint64_t request_site_key;
    uint64_t state_local_thunk_id;
    uint64_t typestate_fallback_thunk_id;
} mc_machine_dispatch_row_t;

typedef enum mc_subscription_op {
    MC_SUBSCRIPTION_ADD = 0,
    MC_SUBSCRIPTION_REMOVE = 1,
} mc_subscription_op_t;

// One staged subscription delta emitted by a successful transition.
typedef struct mc_subscription_update {
    mc_subscription_op_t op;
    mc_machine_id_t machine_id;
    mc_machine_event_kind_t kind;
    uint64_t routing;
} mc_subscription_update_t;

// Staged transaction payload produced by transactional dispatch callback.
// Runtime commits this as one unit only when callback returns `MC_DISPATCH_OK`.
typedef struct mc_machine_dispatch_txn {
    // Whether the transition updates machine state.
    uint64_t has_next_state;
    // Next machine-local state value.
    uint64_t next_state;
    // Next descriptor state tag (0 => keep current tag).
    uint64_t next_state_tag;

    // Outbox effects to commit atomically with state/subscriptions/req-reply.
    const mc_machine_outbox_effect_t *outbox;
    uint32_t outbox_len;

    // Subscription updates to commit atomically with state/outbox/req-reply.
    const mc_subscription_update_t *subscriptions;
    uint32_t subscriptions_len;

    // Request effects to commit atomically with state/outbox/subscriptions.
    const mc_machine_request_effect_t *requests;
    uint32_t requests_len;

    // Reply effects to commit atomically with state/outbox/subscriptions.
    const mc_machine_reply_effect_t *replies;
    uint32_t replies_len;
} mc_machine_dispatch_txn_t;

// Called when an enqueue attempt cannot be delivered.
typedef void (*mc_dead_letter_hook_t)(
    void *ctx,
    mc_machine_id_t dst,
    mc_dead_letter_reason_t reason,
    const mc_machine_envelope_t *env
);

// Called when a dispatch transitions through fault policy.
typedef void (*mc_fault_hook_t)(
    void *ctx,
    mc_machine_id_t machine_id,
    uint64_t fault_code
);

// Transactional dispatch callback executed by
// `__mc_machine_runtime_dispatch_one_txn`.
// Callback receives current machine state and can stage transaction outputs.
typedef mc_dispatch_result_t (*mc_machine_dispatch_txn_fn)(
    void *ctx,
    mc_machine_id_t machine_id,
    uint64_t current_state,
    const mc_machine_envelope_t *env,
    mc_machine_dispatch_txn_t *txn,
    uint64_t *fault_code
);

// Drop callback for one boxed payload layout id.
// Runtime passes the payload box address as opaque pointer.
typedef void (*mc_payload_drop_fn)(void *payload_addr);

// Ring buffer mailbox for one machine.
typedef struct mc_machine_mailbox {
    // Ring buffer storage.
    mc_machine_envelope_t *items;
    // Ring buffer capacity.
    uint32_t cap;
    // Number of queued envelopes.
    uint32_t len;
    // Index of next dequeue.
    uint32_t head;
    // Guard bit to avoid duplicate ready-queue entries.
    uint8_t in_ready_queue;
} mc_machine_mailbox_t;

// One machine table slot.
typedef struct mc_machine_descriptor mc_machine_descriptor_t;
typedef struct mc_machine_slot {
    // Dispatchability state.
    mc_machine_lifecycle_t lifecycle;
    // Machine-local runtime state token (opaque to scheduler).
    mc_machine_state_token_t state_word;
    // Current descriptor state tag (0 when descriptor dispatch is not bound).
    uint64_t state_tag;
    // Optional descriptor metadata used by descriptor-driven dispatch.
    const mc_machine_descriptor_t *descriptor;
    // Optional per-machine dispatch callback used when dispatcher entrypoint
    // does not supply an explicit callback.
    mc_machine_dispatch_txn_fn dispatch;
    // Opaque context pointer paired with `dispatch`.
    void *dispatch_ctx;
    // Bounded FIFO for this machine.
    mc_machine_mailbox_t mailbox;
} mc_machine_slot_t;

// Global ready queue storing machine ids that currently have pending work.
typedef struct mc_ready_queue {
    // Ring buffer of machine ids with pending work.
    mc_machine_id_t *items;
    uint32_t cap;
    uint32_t len;
    uint32_t head;
} mc_ready_queue_t;

// One active subscription mapping.
typedef struct mc_subscription_entry {
    mc_machine_id_t machine_id;
    mc_machine_event_kind_t kind;
    uint64_t routing;
} mc_subscription_entry_t;

// Flat subscription registry used by v1 tests/scaffold.
typedef struct mc_subscription_registry {
    mc_subscription_entry_t *entries;
    uint32_t len;
    uint32_t cap;
} mc_subscription_registry_t;

// Correlation table for request/reply capability ids.
typedef struct mc_pending_correlation_id {
    // Runtime-minted capability id returned to requester as `Pending<T>`.
    uint64_t pending_id;
    // Compiler-provided request-site identity (0 when unknown/not provided).
    uint64_t request_site_key;
} mc_pending_correlation_id_t;

typedef struct mc_pending_reply_entry {
    mc_pending_correlation_id_t correlation;
    mc_machine_id_t requester;
    // Captured request payload ABI so response handlers can bind provenance.
    uint64_t request_payload0;
    mc_payload_layout_id_t request_payload1;
    // Dispatch-step tick at request insertion time.
    // Used by timeout-based inflight cleanup policy.
    uint64_t created_tick;
    uint8_t active;
} mc_pending_reply_entry_t;

typedef struct mc_pending_reply_table {
    mc_pending_reply_entry_t *entries;
    uint32_t len;
    uint32_t cap;
    uint64_t next_cap_id;
} mc_pending_reply_table_t;

// Reason why a pending correlation entry was reclaimed.
typedef enum mc_pending_cleanup_reason {
    // Entry was consumed by successful reply delivery.
    MC_PENDING_CLEANUP_COMPLETED = 1,
    // Requester machine transitioned to STOPPED.
    MC_PENDING_CLEANUP_REQUESTER_STOPPED = 2,
    // Requester machine transitioned to FAULTED.
    MC_PENDING_CLEANUP_REQUESTER_FAULTED = 3,
    // Entry exceeded configured timeout horizon.
    MC_PENDING_CLEANUP_TIMEOUT = 4,
} mc_pending_cleanup_reason_t;

// Optional hook called whenever a pending entry is reclaimed.
typedef void (*mc_pending_lifecycle_hook_t)(
    void *ctx,
    mc_machine_id_t requester,
    uint64_t pending_id,
    uint64_t request_site_key,
    mc_pending_cleanup_reason_t reason
);

// Top-level managed runtime state.
typedef struct mc_machine_runtime {
    // Dense table of machine slots (id = index + 1).
    mc_machine_slot_t *machines;
    uint32_t machine_len;
    uint32_t machine_cap;

    // Global queue of runnable machines.
    mc_ready_queue_t ready;

    // Subscription registry.
    mc_subscription_registry_t subscriptions;

    // Pending request/reply-correlation table.
    mc_pending_reply_table_t pending;

    // Fault lifecycle policy.
    mc_machine_fault_policy_t fault_policy;

    // Optional runtime hooks.
    mc_dead_letter_hook_t dead_letter_hook;
    mc_fault_hook_t fault_hook;
    mc_pending_lifecycle_hook_t pending_hook;
    void *hook_ctx;

    // Monotonic dispatch-step counter used by timeout policy.
    uint64_t dispatch_tick;
    // Pending timeout horizon in dispatch steps.
    // 0 disables timeout cleanup.
    uint64_t pending_timeout_steps;
    // Pending lifecycle counters for observability/tests.
    uint64_t pending_created_count;
    uint64_t pending_cleanup_counts[5];
} mc_machine_runtime_t;

// Initialize runtime state to empty.
void __mc_machine_runtime_init(mc_machine_runtime_t *rt);

// Release all runtime allocations and reset to empty.
void __mc_machine_runtime_drop(mc_machine_runtime_t *rt);

// Configure optional dead-letter and fault callbacks.
void __mc_machine_runtime_set_hooks(
    mc_machine_runtime_t *rt,
    mc_dead_letter_hook_t dead_letter_hook,
    mc_fault_hook_t fault_hook,
    void *hook_ctx
);

// Configure optional pending-lifecycle hook.
// Hook shares `hook_ctx` with dead-letter/fault hooks.
void __mc_machine_runtime_set_pending_hook(
    mc_machine_runtime_t *rt,
    mc_pending_lifecycle_hook_t pending_hook
);

// Set/get runtime fault lifecycle policy.
void __mc_machine_runtime_set_fault_policy(
    mc_machine_runtime_t *rt,
    mc_machine_fault_policy_t policy
);
mc_machine_fault_policy_t __mc_machine_runtime_fault_policy(
    const mc_machine_runtime_t *rt
);

// Set/get timeout horizon for pending correlations.
// `steps == 0` disables timeout cleanup.
void __mc_machine_runtime_set_pending_timeout_steps(
    mc_machine_runtime_t *rt,
    uint64_t steps
);
uint64_t __mc_machine_runtime_pending_timeout_steps(
    const mc_machine_runtime_t *rt
);

// Creates a new managed machine with the requested mailbox capacity.
// Returns 1 on success and writes the machine id to out_id.
uint8_t __mc_machine_runtime_spawn(
    mc_machine_runtime_t *rt,
    uint32_t mailbox_cap,
    mc_machine_id_t *out_id
);

// Query current lifecycle for machine id. Unknown id maps to STOPPED.
mc_machine_lifecycle_t __mc_machine_runtime_lifecycle(
    const mc_machine_runtime_t *rt,
    mc_machine_id_t machine_id
);

// Override lifecycle state for an existing machine.
void __mc_machine_runtime_set_lifecycle(
    mc_machine_runtime_t *rt,
    mc_machine_id_t machine_id,
    mc_machine_lifecycle_t lifecycle
);

// Transition machine from CREATED to RUNNING.
// Returns 1 on success, 0 for unknown id or invalid lifecycle.
uint8_t __mc_machine_runtime_start(
    mc_machine_runtime_t *rt,
    mc_machine_id_t machine_id
);

// Bind one machine-local dispatch callback used by step/dispatch entrypoints
// when no explicit callback argument is provided.
void __mc_machine_runtime_bind_dispatch(
    mc_machine_runtime_t *rt,
    mc_machine_id_t machine_id,
    mc_machine_dispatch_txn_fn dispatch,
    void *dispatch_ctx
);

// Register and resolve dispatch thunk ids used by machine descriptors.
void __mc_machine_runtime_register_thunk(
    uint64_t thunk_id,
    mc_machine_dispatch_txn_fn dispatch
);
// Register thunk metadata for descriptor-driven transitions.
// `next_state_tag` is applied when callback leaves txn.next_state_tag unset.
void __mc_machine_runtime_register_thunk_meta(
    uint64_t thunk_id,
    mc_machine_dispatch_txn_fn dispatch,
    uint64_t next_state_tag
);
mc_machine_dispatch_txn_fn __mc_machine_runtime_lookup_thunk(uint64_t thunk_id);

// Register and resolve payload-drop callbacks by payload layout id.
void __mc_machine_runtime_register_payload_drop(
    mc_payload_layout_id_t layout_id,
    mc_payload_drop_fn drop_fn
);
mc_payload_drop_fn __mc_machine_runtime_lookup_payload_drop(
    mc_payload_layout_id_t layout_id
);

// Resolve a previously-registered thunk id and bind it to a machine slot.
// Returns 1 on success, 0 on unknown machine id or missing thunk id.
uint8_t __mc_machine_runtime_bind_dispatch_thunk(
    mc_machine_runtime_t *rt,
    mc_machine_id_t machine_id,
    uint64_t thunk_id,
    void *dispatch_ctx
);

// Parse and register one machine descriptor blob.
// Returns descriptor id (>0) on success, 0 on parse/alloc failure.
uint64_t __mc_machine_runtime_register_descriptor(
    const uint8_t *descriptor_bytes,
    uint64_t descriptor_len
);

// Bind descriptor-driven dispatch to a machine slot.
// Sets machine state tag used for dispatch-row selection.
// Returns 1 on success, 0 on unknown machine/descriptor id.
uint8_t __mc_machine_runtime_bind_descriptor(
    mc_machine_runtime_t *rt,
    mc_machine_id_t machine_id,
    uint64_t descriptor_id,
    uint64_t initial_state_tag
);

// Set/get opaque machine-local state word.
void __mc_machine_runtime_set_state(
    mc_machine_runtime_t *rt,
    mc_machine_id_t machine_id,
    mc_machine_state_token_t state_word
);
mc_machine_state_token_t __mc_machine_runtime_state(
    const mc_machine_runtime_t *rt,
    mc_machine_id_t machine_id
);

// Enqueue one envelope for destination machine.
//
// Behavior:
// - `CREATED`: accepted and buffered (not scheduled until start).
// - `RUNNING`: accepted and machine is queued once on ready queue.
// - `FAULTED`/`STOPPED`: rejected as not-running.
// - unknown machine id: rejected as unknown.
//
// Dead-letter hook is invoked for unknown/not-running/full cases when configured.
mc_mailbox_enqueue_result_t __mc_machine_runtime_enqueue(
    mc_machine_runtime_t *rt,
    mc_machine_id_t dst,
    const mc_machine_envelope_t *env
);

// Enqueue a request envelope and mint correlation ids for Pending/ReplyCap.
//
// On success:
// - request is enqueued to `dst`
// - envelope delivered to destination has `src` and `reply_cap_id` populated
// - `out_pending_id` receives the minted correlation id
mc_mailbox_enqueue_result_t __mc_machine_runtime_request(
    mc_machine_runtime_t *rt,
    mc_machine_id_t src,
    mc_machine_id_t dst,
    const mc_machine_envelope_t *env,
    uint64_t *out_pending_id
);

// Route a response envelope by reply capability back to the original requester.
//
// On success:
// - response is enqueued to requester machine
// - delivered envelope has `src` and `pending_id` populated
// - corresponding reply capability is consumed
mc_machine_reply_result_t __mc_machine_runtime_reply(
    mc_machine_runtime_t *rt,
    mc_machine_id_t src,
    uint64_t reply_cap_id,
    const mc_machine_envelope_t *env
);

// Managed typestate effect ABI shims used by compiler-lowered `emit`/`reply`.
//
// These APIs are valid only while a managed dispatch callback is executing via
// `__mc_machine_runtime_dispatch_one_txn`. Calls outside dispatch return
// failure/zero and stage nothing.
//
// ABI payload layout:
// - `kind`: event kind used for descriptor dispatch row selection.
// - `payload0`: payload pointer/int payload word.
// - `payload1`: payload layout metadata (layout id + ownership bit).
// - `request_site_key` (request only): compiler-provided request-site identity
//   used to annotate inflight correlation entries.
//
// Return values:
// - send/reply: non-zero on success, zero on failure.
// - request: minted pending id on success, zero on failure.
//
// Success means "staged into the active transaction", not "already delivered".
uint8_t __mc_machine_emit_send(
    uint64_t dst,
    uint64_t kind,
    uint64_t payload0,
    uint64_t payload1
);
uint64_t __mc_machine_emit_request(
    uint64_t dst,
    uint64_t kind,
    uint64_t payload0,
    uint64_t payload1,
    uint64_t request_site_key
);
uint8_t __mc_machine_emit_reply(
    uint64_t cap,
    uint64_t kind,
    uint64_t payload0,
    uint64_t payload1
);

// Executes at most one envelope dispatch using transactional callback.
//
// Transaction model:
// - on `MC_DISPATCH_OK`: commit `(state update, outbox effects, subscription updates, request/reply effects)` atomically.
// - on `MC_DISPATCH_FAULT`: rollback staged outputs and apply fault policy.
// - on `MC_DISPATCH_STOP`: rollback staged outputs and stop machine.
//
// Returns 1 if one envelope was dispatched, 0 if no runnable machine existed.
uint8_t __mc_machine_runtime_dispatch_one_txn(
    mc_machine_runtime_t *rt,
    mc_machine_dispatch_txn_fn dispatch,
    void *dispatch_ctx
);

// Introspection helper for tests/debugging.
uint32_t __mc_machine_runtime_ready_len(const mc_machine_runtime_t *rt);

// Introspection helper for tests/debugging.
uint32_t __mc_machine_runtime_mailbox_len(
    const mc_machine_runtime_t *rt,
    mc_machine_id_t machine_id
);

// Subscription introspection helpers for tests/debugging.
uint32_t __mc_machine_runtime_subscription_len(const mc_machine_runtime_t *rt);
uint8_t __mc_machine_runtime_subscription_contains(
    const mc_machine_runtime_t *rt,
    mc_machine_id_t machine_id,
    mc_machine_event_kind_t kind,
    uint64_t routing
);

// Pending-correlation introspection helpers for tests/debugging.
uint32_t __mc_machine_runtime_pending_len(const mc_machine_runtime_t *rt);
uint8_t __mc_machine_runtime_pending_contains(
    const mc_machine_runtime_t *rt,
    uint64_t pending_id
);
// True only when both pending id and request-site key match an active entry.
uint8_t __mc_machine_runtime_pending_contains_identity(
    const mc_machine_runtime_t *rt,
    uint64_t pending_id,
    uint64_t request_site_key
);
// Returns request-site key for active pending id, or 0 when not found.
uint64_t __mc_machine_runtime_pending_request_site(
    const mc_machine_runtime_t *rt,
    uint64_t pending_id
);
// Pending lifecycle metrics for observability/tests.
uint64_t __mc_machine_runtime_pending_created_count(
    const mc_machine_runtime_t *rt
);
uint64_t __mc_machine_runtime_pending_cleanup_count(
    const mc_machine_runtime_t *rt,
    mc_pending_cleanup_reason_t reason
);

// Opaque-handle runtime bridge for Machina std wrappers.
//
// These helpers expose machine runtime capabilities through plain integer
// handles so user code does not need to model `mc_machine_runtime_t` layout.
// Handle value `0` is always invalid.
//
// Optional bootstrap hook:
// - if binary defines `void __mc_machine_bootstrap(void)`, runtime invokes it
//   once on first `__mc_machine_runtime_new()` call.
uint64_t __mc_machine_runtime_new(void);
void __mc_machine_runtime_free(uint64_t runtime);
// Process-global managed runtime bridge used by `@[machines]` entrypoints.
// - bootstrap: lazily creates and stores process runtime handle, returns it.
// - current: returns active managed runtime handle, or 0 when not bootstrapped.
// - shutdown: drops active managed runtime handle and clears global slot.
uint64_t __mc_machine_runtime_managed_bootstrap_u64(void);
uint64_t __mc_machine_runtime_managed_current_u64(void);
uint64_t __mc_machine_runtime_managed_shutdown_u64(void);
uint64_t __mc_machine_runtime_spawn_u64(uint64_t runtime, uint64_t mailbox_cap);
uint64_t __mc_machine_runtime_start_u64(uint64_t runtime, uint64_t machine_id);
uint64_t __mc_machine_runtime_send_u64(
    uint64_t runtime,
    uint64_t dst,
    uint64_t kind,
    uint64_t payload0,
    uint64_t payload1
);
uint64_t __mc_machine_runtime_request_u64(
    uint64_t runtime,
    uint64_t src,
    uint64_t dst,
    uint64_t kind,
    uint64_t payload0,
    uint64_t payload1
);
uint64_t __mc_machine_runtime_reply_u64(
    uint64_t runtime,
    uint64_t src,
    uint64_t reply_cap_id,
    uint64_t kind,
    uint64_t payload0,
    uint64_t payload1
);
// Bind machine-local dispatch callback through opaque-handle bridge.
// `dispatch_fn` is a `mc_machine_dispatch_txn_fn` pointer encoded as `u64`.
// `dispatch_ctx` is an opaque pointer value passed to callback.
// Returns 1 on success, 0 on invalid handle/id.
uint64_t __mc_machine_runtime_bind_dispatch_u64(
    uint64_t runtime,
    uint64_t machine_id,
    uint64_t dispatch_fn,
    uint64_t dispatch_ctx
);
// Register thunk id -> dispatch function pointer in process-global registry.
void __mc_machine_runtime_register_thunk_u64(uint64_t thunk_id, uint64_t dispatch_fn);
void __mc_machine_runtime_register_payload_drop_u64(
    uint64_t layout_id,
    uint64_t drop_fn
);
// Register thunk metadata through opaque-handle bridge.
void __mc_machine_runtime_register_thunk_meta_u64(
    uint64_t thunk_id,
    uint64_t dispatch_fn,
    uint64_t next_state_tag
);
// Resolve thunk id through runtime global thunk registry and bind to machine.
uint64_t __mc_machine_runtime_bind_dispatch_thunk_u64(
    uint64_t runtime,
    uint64_t machine_id,
    uint64_t thunk_id,
    uint64_t dispatch_ctx
);
// Bridge wrappers for descriptor registration/binding.
uint64_t __mc_machine_runtime_register_descriptor_u64(
    uint64_t descriptor_ptr,
    uint64_t descriptor_len
);
uint64_t __mc_machine_runtime_bind_descriptor_u64(
    uint64_t runtime,
    uint64_t machine_id,
    uint64_t descriptor_id,
    uint64_t initial_state_tag
);
// Runs one dispatch step through the managed runtime bridge.
// Returns `mc_machine_step_status_t` value.
uint64_t __mc_machine_runtime_step_u64(uint64_t runtime);

#endif
